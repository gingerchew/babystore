{
  "version": 3,
  "sources": ["../src/deepAssign.js", "../src/index.js"],
  "sourcesContent": ["\nconst deepAssign = (orig,...args) => {\n\n\t// Make sure there are objects to merge\n\tlet i = 0, l = args.length, next;\n\n\tif (l > 0)\n        // Merge all objects into first\n        for(;i<l;i++) \n            // If it's an object, recursively merge\n            // Otherwise, push to key\n            for (let key in next = args[i]) \n                orig[key] = toString.call(next[key])[8]=='O'\n                    ? deepAssign(orig[key] || {}, next[key]) \n                    : next[key];\n\n\treturn orig;\n}\n\nexport {\n    deepAssign\n}", "// @ts-check\nimport { deepAssign } from './deepAssign.js';\n\n/**\n * @typedef {{[key: string]: unknown}|unknown} ReduceableObject\n */\n\n/**\n * @typedef babystoreFuncs\n * @property {(key: string, ...keys: string[]) => any} find\n * @property {(key: string, obj: { [key: string]: unknown }) => void} add\n * @property {(key: string) => void} delete\n * @property {(key: string) => boolean} has\n * @property {(_?: unknown) => any[]} all\n */\n\n/**\n * @typedef {{ [key in keyof babystoreFuncs]: babystoreFuncs[key] }} babystore\n */\n\n\nlet /** @type {undefined} */ undef,\n    lS=localStorage,\n    qd =/**\n         * @param {ReduceableObject} result\n         * @param {string} key\n         * @param {number} index\n         * @param {string[]} arr\n         * @returns {ReduceableObject}\n         */ (result, key) => result == null \n                ? result \n                : (\n                    toString.call(result)[8]=='O' && \n                    // @ts-ignore\n                    key in result\n                ) \n                ? result[key] \n                : result,\n    /**\n     * @type babystoreFuncs\n     */\n    $$ = {\n        find: (key, ...keys) => key in lS && keys.reduce(qd, JSON.parse(lS.getItem(key))),\n        add: (key, obj) => lS.setItem(\n            key, \n            JSON.stringify(\n                key in lS ? \n                deepAssign(\n                    JSON.parse(lS.getItem(key)),\n                    obj\n                ) : obj\n            )\n        ),\n        delete: key => key==undef?lS.clear():lS.removeItem(key),\n        has: key => key in lS,\n        all: _ => Array.from(lS, (_n, i) => JSON.parse(lS.getItem(lS.key(i)))),\n    },\n    s = /**\n         * @param {string} [$]\n         * @returns {babystore}\n         */ \n       $ => new Proxy($$, {\n           apply: (_target, _, [key, obj={}]) => (key = $==undef||key==undef?key:$+key, $$[_](\n               key,\n               obj\n           ))\n       })\n// doing it this way brings down the esbuild package size\nexport {\n    s as default\n}"],
  "mappings": "AACA,GAAM,GAAa,CAAC,KAAQ,IAAS,CAGpC,GAAI,GAAI,EAAG,EAAI,EAAK,OAAQ,EAE5B,GAAI,EAAI,EAED,KAAK,EAAE,EAAE,IAGL,OAAS,KAAO,GAAO,EAAK,GACxB,EAAK,GAAO,SAAS,KAAK,EAAK,IAAM,IAAI,IACnC,EAAW,EAAK,IAAQ,GAAI,EAAK,IACjC,EAAK,GAE1B,MAAO,ICKR,GAA6B,GACzB,EAAG,aACH,EAMQ,CAAC,EAAQ,IAAQ,GAAU,KACrB,EAEE,SAAS,KAAK,GAAQ,IAAI,KAE1B,IAAO,GAET,EAAO,GACP,EAId,EAAK,CACD,KAAM,CAAC,KAAQ,IAAS,IAAO,IAAM,EAAK,OAAO,EAAI,KAAK,MAAM,EAAG,QAAQ,KAC3E,IAAK,CAAC,EAAK,IAAQ,EAAG,QAClB,EACA,KAAK,UACD,IAAO,GACP,EACI,KAAK,MAAM,EAAG,QAAQ,IACtB,GACA,IAGZ,OAAQ,GAAO,GAAK,EAAM,EAAG,QAAQ,EAAG,WAAW,GACnD,IAAK,GAAO,IAAO,GACnB,IAAK,GAAK,MAAM,KAAK,EAAI,CAAC,EAAI,IAAM,KAAK,MAAM,EAAG,QAAQ,EAAG,IAAI,OAErE,EAIG,GAAK,GAAI,OAAM,EAAI,CACf,MAAO,CAAC,EAAS,EAAG,CAAC,EAAK,EAAI,MAAS,GAAM,GAAG,GAAO,GAAK,EAAM,EAAI,EAAE,EAAK,EAAG,GAC5E,EACA",
  "names": []
}
