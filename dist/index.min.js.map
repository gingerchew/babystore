{
  "version": 3,
  "sources": ["../src/deepAssign.js", "../src/index.js"],
  "sourcesContent": ["// @ts-check\n\n/** @type {import(\"../types\").DeepAssign} */\nconst deepAssign = (orig,...args) => {\n\n\t// Make sure there are objects to merge\n\tif (args.length > 0)\n        // Merge all objects into first\n        for(let i=0,next,key;i<args.length;i++) \n            // If it's an object, recursively merge\n            // Otherwise, push to key\n            for (key in next = args[i]) \n                orig[key] = toString.call(next[key])[8]=='O'\n                    ? deepAssign(orig[key] || {}, next[key]) \n                    : next[key];\n\n\treturn orig;\n}\n\nexport {\n    deepAssign\n}", "// @ts-check\nimport { deepAssign } from './deepAssign.js';\n\nlet /** @type {undefined} */ undef,\n    lS=localStorage,\n    J=JSON,\n    /** @type {(v: string|unknown) => unknown} */\n    p=v=>{\n        try {\n            // @ts-ignore\n            v=J.parse(v);\n        }catch{}finally{\n            return v;\n        }\n    },\n    /** @type {import(\"../types\").qd} */\n    qd = (result, key) => result == null\n        ? result\n        : (\n            toString.call(result)[8]=='O' &&\n            // @ts-ignore\n            key in result\n        )\n            ? result[key]\n            : result,\n    /** @type {import(\"../types\").babystoreFuncs} */\n    $$ = {\n        find: (key, ...keys) => key in lS && keys.length ? keys.reduce(qd, J.parse(lS[key])) : lS[key],\n        add: (key, obj) => lS[key] = J.stringify(\n            key in lS ? \n            deepAssign(\n                // @ts-ignore\n                p(lS[key]),\n                obj\n            ) : obj\n        ),\n        delete: key => lS.removeItem(key),\n        clear: () => lS.clear(),\n        has: key => key in lS,\n        all: () => Array.from(lS, (_n, i) => p(lS.getItem(lS.key(i) || ''))),\n    },\n    s = /**\n        * @param {string} [$]\n        * @returns {import(\"../types\").babystore}\n        */ \n        $ => new Proxy($$, {\n            apply: (_target, fn, [key, obj={}]) => (key = $==undef||key==undef?key:$+key, $$[fn](\n                key,\n                obj\n            ))\n        }), \n    a = /**\n        * @param {string} [$]\n        * @returns {import(\"../types\").babystore}\n        */\n        $ => new Proxy($$, {\n            apply: (_target, fn, [key, obj={}]) => (key = $==undef||key==undef?key:$+key, () => Promise.resolve($$[fn](\n                key,\n                obj\n            )))\n        });\n// doing it this way brings down the esbuild package size\nexport const store = s;\nexport const storeAsync = a;"],
  "mappings": "AAGA,GAAM,GAAa,CAAC,KAAQ,IAAS,CAGpC,GAAI,EAAK,OAAS,EAEX,OAAQ,GAAE,EAAE,EAAK,EAAI,EAAE,EAAK,OAAO,IAG/B,IAAK,IAAO,GAAO,EAAK,GACpB,EAAK,GAAO,SAAS,KAAK,EAAK,IAAM,IAAI,IACnC,EAAW,EAAK,IAAQ,GAAI,EAAK,IACjC,EAAK,GAE1B,MAAO,ICbR,GAA6B,GACzB,EAAG,aACH,EAAE,KAEF,EAAE,GAAG,CACD,GAAI,CAEA,EAAE,EAAE,MAAM,QACb,SAAO,CACJ,MAAO,KAIf,EAAK,CAAC,EAAQ,IAAQ,GAAU,KAC1B,EAEE,SAAS,KAAK,GAAQ,IAAI,KAE1B,IAAO,GAEL,EAAO,GACP,EAEV,EAAK,CACD,KAAM,CAAC,KAAQ,IAAS,IAAO,IAAM,EAAK,OAAS,EAAK,OAAO,EAAI,EAAE,MAAM,EAAG,KAAS,EAAG,GAC1F,IAAK,CAAC,EAAK,IAAQ,EAAG,GAAO,EAAE,UAC3B,IAAO,GACP,EAEI,EAAE,EAAG,IACL,GACA,GAER,OAAQ,GAAO,EAAG,WAAW,GAC7B,MAAO,IAAM,EAAG,QAChB,IAAK,GAAO,IAAO,GACnB,IAAK,IAAM,MAAM,KAAK,EAAI,CAAC,EAAI,IAAM,EAAE,EAAG,QAAQ,EAAG,IAAI,IAAM,OAEnE,EAII,GAAK,GAAI,OAAM,EAAI,CACf,MAAO,CAAC,EAAS,EAAI,CAAC,EAAK,EAAI,MAAS,GAAM,GAAG,GAAO,GAAK,EAAM,EAAI,EAAE,EAAK,EAAG,GAC7E,EACA,MAGZ,EAII,GAAK,GAAI,OAAM,EAAI,CACf,MAAO,CAAC,EAAS,EAAI,CAAC,EAAK,EAAI,MAAS,GAAM,GAAG,GAAO,GAAK,EAAM,EAAI,EAAE,EAAK,IAAM,QAAQ,QAAQ,EAAG,GACnG,EACA,OAIH,EAAQ,EACR,EAAa",
  "names": []
}
